# 题意
给出一些(<=10^5)富翁的姓名、年龄和财富，接下来有K(K<=1000)个询问，对每个询问输出年龄在[l,r]中的最富有的m(m <= 100)个人的信息，先按照财富从大到小排，财富相同按年龄从小到大，年龄相同按名字字典序排

# 解法
一开始暴力瞎搞超时了QAQ，然后没想到什么好的办法就随便瞎搞然后T了5、6次然后莫名过了。。

神奇的瞎搞做法如下：
- 读入富翁数据的同时按照年龄分组排序
- 对于每个询问，进行m轮循环：
- + 取年龄区间内排名最靠前的，输出，然后将这个人删去
- + 若无人可取了，跳出循环
- 将每个年龄区间回退到未删除任何人的状态，等待下一轮询问

上述过程最关键的地方在于，要快速完成最后一步的回退操作，所以想到了可持久化，每个年龄都可以在O(1)的时间内做到回退，然而我并不会打可持久化。。所以直接用了rope来搞可持久化，rope的本质是颗平衡树，各项操作（插入、删除等）的复杂度均为O(log(n))，而拷贝复杂度可以做到O(1)（因为只拷贝了根节点），这样对每一轮询问的最坏复杂度100*(200*log(n)+log(n))+200约为20100*log(n)，最坏有1000轮询问，所以总的最坏时间复杂度为2*10^7*log(n),这个复杂度不特意卡的话基本没问题，不过实际复杂度会比这个小不少（因为200个年龄段平均分配10^5的话相当于n已经降到500了。

另外看网上题解基本都是利用m <= 100这一条件来减少每个年龄的人数的（我怎么没想到呢。。）